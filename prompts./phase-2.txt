ğŸŸ¢ Phase 2 â€” Routing & Navigation (3â€“5 hours)

Goal: Learn how apps are structured.

3. App Router Basics

Hands-on tasks:

Create pages in app/page.tsx, app/about/page.tsx

Add server components + client components

Document:

Difference between server/client components

File-based routing concept

4. Dynamic Routing

Create:

app/blog/[id]/page.tsx


Document:

How params work

Why Next.js uses server components by default

5. Layouts & Templates

Build:

A main layout with a navbar

A nested layout for blog pages

Document:

Difference between layout.tsx and template.tsx



ğŸŸ¢ PHASE 2 â€” Routing & Navigation (Detailed Learning)
3. App Router Basics

The App Router is a powerful routing system introduced in Next.js 13+.
It uses your folder structure inside the app/ directory to automatically create routes.

âœ… 3.1. Create Basic Pages (Hands On)

Inside your project, go to:
/app/page.js (this is the homepage)

ğŸ“ STEP 1 â€” Confirm page.js
export default function Home() {
  return (
    <main style={{ padding: "20px" }}>
      <h1>Home Page</h1>
      <p>This is rendered on the server by default.</p>
    </main>
  );
}

ğŸ“ STEP 2 â€” Create About Page

Create new folder:
app/about/

Inside it create:
app/about/page.js

Add:

export default function About() {
  return (
    <main style={{ padding: "20px" }}>
      <h1>About Page</h1>
      <p>This page is also a server component by default.</p>
    </main>
  );
}

Result

Visiting http://localhost:3000
 â†’ Home Page

Visiting http://localhost:3000/about
 â†’ About Page

No router library. No configuration.
Your folders = your routes.

ğŸ“˜ Documentation Part: File-Based Routing

You should document this:

In Next.js, the folder and file structure inside the app/ directory determines the URL structure.

app/page.js â†’ /

app/about/page.js â†’ /about

There is no need for React Router or a manual routing system. The filesystem is the router.

ğŸŸ£ 3.2. Server Components vs Client Components

By default, every component in the app folder is a Server Component.

ğŸ”µ Server Component

Runs on the server, not the browser.

Cannot use useState, useEffect, or event listeners.

Very fast and secure (because code never ships to the client).

Perfect for data fetching.

Example (default):

export default function Home() {
  return <h1>Server Component</h1>;
}

ğŸ”´ Client Component

To make a component run in the browser, add:

"use client";


Example:

"use client";

export default function ClickButton() {
  return (
    <button onClick={() => alert("Client component running!")}>
      Click Me
    </button>
  );
}


Use this when you need:

interactivity

state

event handlers

browser APIs

ğŸ“˜ Documentation Part: Difference Between Server & Client Components

Add this to your notes:

Feature	Server Component	Client Component
Runs on	Server	Browser
Can use useState	âŒ No	âœ” Yes
Can use useEffect	âŒ No	âœ” Yes
Can access database	âœ” Yes	âŒ No
Has better performance	âœ” Yes	Moderate
Needs "use client"	âŒ No	âœ” Yes
4. Dynamic Routing

Dynamic routes allow URLs like:

/blog/1
/blog/hello-world
/blog/user-123


Anything inside square brackets [id] becomes a dynamic parameter.

ğŸŸ¢ 4.1. Create Dynamic Route (Hands On)

Create folder:
app/blog/[id]/

Inside it create file:
app/blog/[id]/page.js

Add:

export default function BlogPost({ params }) {
  return (
    <main style={{ padding: "20px" }}>
      <h1>Blog Post: {params.id}</h1>
      <p>This is a dynamic route in Next.js.</p>
    </main>
  );
}


Run:
http://localhost:3000/blog/123

http://localhost:3000/blog/hello-world

ğŸ“˜ Documentation Part: How Params Work

Document:

In a dynamic route like app/blog/[id]/page.js, the value in brackets becomes a URL parameter.

Next.js automatically provides a params object to the component:

export default function BlogPost({ params }) {
  console.log(params); // { id: "hello-world" }
}


This makes it easy to render content based on the URL.

ğŸ” Why Next.js Uses Server Components by Default

Document this:

Next.js uses Server Components by default because they:

Reduce the amount of JavaScript sent to the browser

Improve performance

Allow secure access to databases & APIs

Allow faster initial page loads

Reduce bundle size

Client components are only used when necessary (state, interactivity, browser APIs).

5. Layouts & Templates

Layouts introduce shared UI across multiple pages.

ğŸŸ¢ 5.1. Create a Main Layout with Navbar (Hands On)

Open your root layout:
app/layout.js

Replace content with:

import "./globals.css";

export const metadata = {
  title: "My Next.js App",
  description: "Learning Next.js with hands-on examples",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <nav style={{ padding: "10px", borderBottom: "1px solid #ccc" }}>
          <a href="/" style={{ marginRight: "10px" }}>Home</a>
          <a href="/about" style={{ marginRight: "10px" }}>About</a>
          <a href="/blog/first-post">Blog Example</a>
        </nav>
        <main style={{ padding: "20px" }}>
          {children}
        </main>
      </body>
    </html>
  );
}


Now every page inherits this navbar.

ğŸŸ£ 5.2. Create a Nested Layout for Blog Pages

Create this file:
app/blog/layout.js

Add:

export default function BlogLayout({ children }) {
  return (
    <section style={{ border: "2px solid #888", padding: "20px" }}>
      <h2>Blog Section</h2>
      {children}
    </section>
  );
}


This layout wraps ONLY pages under /blog.

ğŸ“˜ Documentation Part: Difference Between layout.js and template.js
âœ” layout.js

Shared UI that persists between page navigations

Great for navbars, sidebars, footers

Not re-mounted when navigating

âœ” template.js

Renders new UI every time

Useful when you want animations OR reset state on route change

Always re-mounted

Add this to documentation:

Feature	layout.js	template.js
Persists between navigations	âœ” Yes	âŒ No
Good for navbars & shared wrappers	âœ” Yes	âŒ No
Remounts on navigation	âŒ No	âœ” Yes
Good for animations per page	âŒ No	âœ” Yes